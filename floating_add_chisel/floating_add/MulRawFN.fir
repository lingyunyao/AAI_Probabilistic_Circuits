circuit MulRawFN :
  module MulFullRawFN :
    output io : { flip a : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, sExp : SInt<10>, sig : UInt<23>}, flip b : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, sExp : SInt<10>, sig : UInt<23>}, invalidExc : UInt<1>, rawOut : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, sExp : SInt<10>, sig : UInt<48>}}

    node _notSigNaN_invalidExc_T = and(io.a.isInf, io.b.isZero) @[multi.scala 34:44]
    node _notSigNaN_invalidExc_T_1 = and(io.a.isZero, io.b.isInf) @[multi.scala 34:76]
    node notSigNaN_invalidExc = or(_notSigNaN_invalidExc_T, _notSigNaN_invalidExc_T_1) @[multi.scala 34:60]
    node notNaN_isInfOut = or(io.a.isInf, io.b.isInf) @[multi.scala 35:38]
    node notNaN_isZeroOut = or(io.a.isZero, io.b.isZero) @[multi.scala 36:40]
    node _common_sExpOut_T = add(io.a.sExp, io.b.sExp) @[multi.scala 39:36]
    node _common_sExpOut_T_1 = tail(_common_sExpOut_T, 1) @[multi.scala 39:36]
    node _common_sExpOut_T_2 = asSInt(_common_sExpOut_T_1) @[multi.scala 39:36]
    node _common_sExpOut_T_3 = sub(_common_sExpOut_T_2, asSInt(UInt<9>("hff"))) @[multi.scala 39:48]
    node _common_sExpOut_T_4 = tail(_common_sExpOut_T_3, 1) @[multi.scala 39:48]
    node common_sExpOut = asSInt(_common_sExpOut_T_4) @[multi.scala 39:48]
    node _common_sigOut_T = cat(UInt<1>("h1"), io.a.sig) @[Cat.scala 33:92]
    node _common_sigOut_T_1 = cat(UInt<1>("h1"), io.b.sig) @[Cat.scala 33:92]
    node _common_sigOut_T_2 = mul(_common_sigOut_T, _common_sigOut_T_1) @[multi.scala 41:49]
    node common_sigOut = bits(_common_sigOut_T_2, 47, 0) @[multi.scala 41:74]
    node _io_invalidExc_T = eq(io.a.isInf, UInt<1>("h0")) @[add.scala 18:16]
    node _io_invalidExc_T_1 = and(io.a.isNaN, _io_invalidExc_T) @[add.scala 18:13]
    node _io_invalidExc_T_2 = eq(io.a.isZero, UInt<1>("h0")) @[add.scala 18:28]
    node _io_invalidExc_T_3 = and(_io_invalidExc_T_1, _io_invalidExc_T_2) @[add.scala 18:25]
    node _io_invalidExc_T_4 = bits(io.a.sExp, 8, 0) @[add.scala 18:47]
    node _io_invalidExc_T_5 = eq(_io_invalidExc_T_4, UInt<9>("h1ff")) @[add.scala 18:65]
    node _io_invalidExc_T_6 = and(_io_invalidExc_T_3, _io_invalidExc_T_5) @[add.scala 18:38]
    node _io_invalidExc_T_7 = bits(io.a.sig, 22, 22) @[add.scala 18:101]
    node _io_invalidExc_T_8 = eq(_io_invalidExc_T_7, UInt<1>("h0")) @[add.scala 18:116]
    node _io_invalidExc_T_9 = and(_io_invalidExc_T_6, _io_invalidExc_T_8) @[add.scala 18:93]
    node _io_invalidExc_T_10 = bits(io.a.sig, 21, 0) @[add.scala 18:132]
    node _io_invalidExc_T_11 = neq(_io_invalidExc_T_10, UInt<1>("h0")) @[add.scala 18:150]
    node _io_invalidExc_T_12 = and(_io_invalidExc_T_9, _io_invalidExc_T_11) @[add.scala 18:124]
    node _io_invalidExc_T_13 = eq(io.b.isInf, UInt<1>("h0")) @[add.scala 18:16]
    node _io_invalidExc_T_14 = and(io.b.isNaN, _io_invalidExc_T_13) @[add.scala 18:13]
    node _io_invalidExc_T_15 = eq(io.b.isZero, UInt<1>("h0")) @[add.scala 18:28]
    node _io_invalidExc_T_16 = and(_io_invalidExc_T_14, _io_invalidExc_T_15) @[add.scala 18:25]
    node _io_invalidExc_T_17 = bits(io.b.sExp, 8, 0) @[add.scala 18:47]
    node _io_invalidExc_T_18 = eq(_io_invalidExc_T_17, UInt<9>("h1ff")) @[add.scala 18:65]
    node _io_invalidExc_T_19 = and(_io_invalidExc_T_16, _io_invalidExc_T_18) @[add.scala 18:38]
    node _io_invalidExc_T_20 = bits(io.b.sig, 22, 22) @[add.scala 18:101]
    node _io_invalidExc_T_21 = eq(_io_invalidExc_T_20, UInt<1>("h0")) @[add.scala 18:116]
    node _io_invalidExc_T_22 = and(_io_invalidExc_T_19, _io_invalidExc_T_21) @[add.scala 18:93]
    node _io_invalidExc_T_23 = bits(io.b.sig, 21, 0) @[add.scala 18:132]
    node _io_invalidExc_T_24 = neq(_io_invalidExc_T_23, UInt<1>("h0")) @[add.scala 18:150]
    node _io_invalidExc_T_25 = and(_io_invalidExc_T_22, _io_invalidExc_T_24) @[add.scala 18:124]
    node _io_invalidExc_T_26 = or(_io_invalidExc_T_12, _io_invalidExc_T_25) @[multi.scala 45:59]
    node _io_invalidExc_T_27 = or(_io_invalidExc_T_26, notSigNaN_invalidExc) @[multi.scala 45:99]
    io.invalidExc <= _io_invalidExc_T_27 @[multi.scala 45:19]
    io.rawOut.isInf <= notNaN_isInfOut @[multi.scala 46:21]
    io.rawOut.isZero <= notNaN_isZeroOut @[multi.scala 47:22]
    node _io_rawOut_isNaN_T = or(io.a.isNaN, io.b.isNaN) @[multi.scala 49:35]
    io.rawOut.isNaN <= _io_rawOut_isNaN_T @[multi.scala 49:21]
    when notNaN_isZeroOut : @[multi.scala 51:29]
      io.rawOut.sExp <= asSInt(UInt<1>("h0")) @[multi.scala 54:24]
      io.rawOut.sig <= UInt<1>("h0") @[multi.scala 55:23]
    else :
      node _T = bits(common_sigOut, 47, 47) @[multi.scala 56:31]
      node _T_1 = eq(_T, UInt<1>("h1")) @[multi.scala 56:51]
      when _T_1 : @[multi.scala 56:60]
        node _io_rawOut_sExp_T = add(common_sExpOut, asSInt(UInt<2>("h1"))) @[multi.scala 57:42]
        node _io_rawOut_sExp_T_1 = tail(_io_rawOut_sExp_T, 1) @[multi.scala 57:42]
        node _io_rawOut_sExp_T_2 = asSInt(_io_rawOut_sExp_T_1) @[multi.scala 57:42]
        io.rawOut.sExp <= _io_rawOut_sExp_T_2 @[multi.scala 57:24]
        node _io_rawOut_sig_T = shl(common_sigOut, 1) @[multi.scala 58:40]
        io.rawOut.sig <= _io_rawOut_sig_T @[multi.scala 58:23]
      else :
        io.rawOut.sExp <= common_sExpOut @[multi.scala 60:24]
        io.rawOut.sig <= common_sigOut @[multi.scala 61:23]


  module MulRawFN :
    output io : { flip a : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, sExp : SInt<10>, sig : UInt<23>}, flip b : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, sExp : SInt<10>, sig : UInt<23>}, invalidExc : UInt<1>, rawOut : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, sExp : SInt<10>, sig : UInt<23>}}

    inst mulFullRaw of MulFullRawFN @[multi.scala 74:28]
    mulFullRaw.io.a.sig <= io.a.sig @[multi.scala 76:21]
    mulFullRaw.io.a.sExp <= io.a.sExp @[multi.scala 76:21]
    mulFullRaw.io.a.isZero <= io.a.isZero @[multi.scala 76:21]
    mulFullRaw.io.a.isInf <= io.a.isInf @[multi.scala 76:21]
    mulFullRaw.io.a.isNaN <= io.a.isNaN @[multi.scala 76:21]
    mulFullRaw.io.b.sig <= io.b.sig @[multi.scala 77:21]
    mulFullRaw.io.b.sExp <= io.b.sExp @[multi.scala 77:21]
    mulFullRaw.io.b.isZero <= io.b.isZero @[multi.scala 77:21]
    mulFullRaw.io.b.isInf <= io.b.isInf @[multi.scala 77:21]
    mulFullRaw.io.b.isNaN <= io.b.isNaN @[multi.scala 77:21]
    io.invalidExc <= mulFullRaw.io.invalidExc @[multi.scala 79:19]
    io.rawOut <= mulFullRaw.io.rawOut @[multi.scala 80:15]
    node roundBit = bits(mulFullRaw.io.rawOut.sig, 23, 23) @[multi.scala 87:23]
    node _stickyBit_T = bits(mulFullRaw.io.rawOut.sig, 22, 0) @[multi.scala 88:24]
    node stickyBit = orr(_stickyBit_T) @[multi.scala 88:42]
    node _roundUp_T = bits(mulFullRaw.io.rawOut.sig, 24, 24) @[multi.scala 89:34]
    node _roundUp_T_1 = or(_roundUp_T, stickyBit) @[multi.scala 89:49]
    node roundUp = and(roundBit, _roundUp_T_1) @[multi.scala 89:28]
    node _io_rawOut_sig_T = bits(mulFullRaw.io.rawOut.sig, 47, 25) @[multi.scala 90:38]
    node _io_rawOut_sig_T_1 = add(_io_rawOut_sig_T, UInt<1>("h1")) @[multi.scala 90:71]
    node _io_rawOut_sig_T_2 = tail(_io_rawOut_sig_T_1, 1) @[multi.scala 90:71]
    node _io_rawOut_sig_T_3 = bits(mulFullRaw.io.rawOut.sig, 47, 25) @[multi.scala 90:81]
    node _io_rawOut_sig_T_4 = mux(roundUp, _io_rawOut_sig_T_2, _io_rawOut_sig_T_3) @[multi.scala 90:25]
    io.rawOut.sig <= _io_rawOut_sig_T_4 @[multi.scala 90:19]

