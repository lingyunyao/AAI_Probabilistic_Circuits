import chisel3._
import chisel3.stage.{ChiselStage, ChiselGeneratorAnnotation}
import hardfloat._
import chisel3.util._

class RawFloat(expWidth: Int, sigWidth: Int) extends Bundle {
  val isNaN = Bool()
  val isInf = Bool()
  val isZero = Bool()
  val exp = UInt((expWidth).W)
  val sig = UInt(sigWidth.W)
}

object Utils {
  def isSigNaNUnsignedRawFloat(x: RawFloat): Bool = {
    val expWidth = x.exp.getWidth - 1
    val sigWidth = x.sig.getWidth
    x.isNaN && !x.isInf && !x.isZero && x.exp(expWidth - 1, 0) === ((1 << expWidth) - 1).U && x.sig(sigWidth - 1) === 0.U && x.sig(sigWidth - 2, 0) =/= 0.U
  }
}



//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//class AddRawFN(expWidth: Int, sigWidth: Int) extends RawModule
class AddRawFN(expWidth: Int, sigWidth: Int) extends Module
{
    val io = IO(new Bundle {
        //val subOp = Input(Bool())
        val a = Input(new RawFloat(expWidth, sigWidth))
        val b = Input(new RawFloat(expWidth, sigWidth))
        val invalidExc = Output(Bool())
        val rawOut = Output(new RawFloat(expWidth, sigWidth))
    })

    val notSigNaN_invalidExc = (io.a.isInf && io.b.isZero) || (io.a.isZero && io.b.isInf)
    val notNaN_isInfOut = io.a.isInf || io.b.isInf
    val notNaN_isZeroOut = io.a.isZero || io.b.isZero

    val common_exp = Wire(UInt(expWidth.W))
    val small_sig = Wire(UInt((sigWidth).W))
    val large_sig = Wire(UInt((sigWidth).W))
    val modNatAlignDist = Wire(UInt((expWidth + 1).W))

    val sDiffExps = Cat(0.U(1.W), io.a.exp) - Cat(0.U(1.W), io.b.exp)

    when (sDiffExps(expWidth) === 1.U(1.W)) {
        modNatAlignDist := -sDiffExps(expWidth - 1, 0)
        common_exp := io.b.exp
        small_sig := io.a.sig
        large_sig := io.b.sig
    }.otherwise {
        modNatAlignDist := sDiffExps(expWidth - 1, 0)
        common_exp := io.a.exp
        small_sig := io.b.sig
        large_sig := io.a.sig
    }

    val shifted_sig = Mux(modNatAlignDist > (sigWidth + 1).U, 0.U, Cat(1.U(1.W), small_sig) >> modNatAlignDist)(sigWidth, 0)


    val sig_sum = (Cat(1.U(1.W), large_sig) + shifted_sig)(sigWidth + 1, 0)
    //val result_exp = UInt((expWidth).W)
    
    when (sig_sum(sigWidth) === 1.U(1.W)) {
      io.rawOut.sig := sig_sum(sigWidth - 1, 0)
      io.rawOut.exp := common_exp + 1.U

    } .otherwise {
      io.rawOut.sig := sig_sum(sigWidth - 1, 0)
      io.rawOut.exp := common_exp

    }

    //io.rawOut.sig := sig_sum(sigWidth - 1, 0)
    //io.rawOut.exp := common_exp
    io.rawOut.isNaN := io.a.isNaN || io.b.isNaN
    io.rawOut.isInf := notNaN_isInfOut
    io.rawOut.isZero := notNaN_isZeroOut
    io.invalidExc := Utils.isSigNaNUnsignedRawFloat(io.a) || Utils.isSigNaNUnsignedRawFloat(io.b) || notSigNaN_invalidExc    
    //val norm_shift = Reg(UInt(sigWidth.W))
}

