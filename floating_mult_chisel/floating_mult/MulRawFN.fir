circuit MulRawFN :
  module MulFullRawFN :
    input clock : Clock
    input reset : Reset
    output io : { flip a : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, exp : UInt<9>, sig : UInt<23>}, flip b : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, exp : UInt<9>, sig : UInt<23>}, invalidExc : UInt<1>, rawOut : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, exp : UInt<9>, sig : UInt<48>}}

    node _notSigNaN_invalidExc_T = and(io.a.isInf, io.b.isZero) @[multi.scala 34:44]
    node _notSigNaN_invalidExc_T_1 = and(io.a.isZero, io.b.isInf) @[multi.scala 34:76]
    node notSigNaN_invalidExc = or(_notSigNaN_invalidExc_T, _notSigNaN_invalidExc_T_1) @[multi.scala 34:60]
    node notNaN_isInfOut = or(io.a.isInf, io.b.isInf) @[multi.scala 35:38]
    node notNaN_isZeroOut = or(io.a.isZero, io.b.isZero) @[multi.scala 36:40]
    node _common_expOut_T = add(io.a.exp, io.b.exp) @[multi.scala 39:34]
    node _common_expOut_T_1 = tail(_common_expOut_T, 1) @[multi.scala 39:34]
    node _common_expOut_T_2 = sub(_common_expOut_T_1, UInt<8>("hff")) @[multi.scala 39:45]
    node common_expOut = tail(_common_expOut_T_2, 1) @[multi.scala 39:45]
    node _common_sigOut_T = cat(UInt<1>("h1"), io.a.sig) @[Cat.scala 33:92]
    node _common_sigOut_T_1 = cat(UInt<1>("h1"), io.b.sig) @[Cat.scala 33:92]
    node _common_sigOut_T_2 = mul(_common_sigOut_T, _common_sigOut_T_1) @[multi.scala 41:49]
    node common_sigOut = bits(_common_sigOut_T_2, 47, 0) @[multi.scala 41:74]
    reg common_expOut_reg : UInt, clock with :
      reset => (UInt<1>("h0"), common_expOut_reg) @[multi.scala 45:36]
    common_expOut_reg <= common_expOut @[multi.scala 45:36]
    reg common_sigOut_reg : UInt, clock with :
      reset => (UInt<1>("h0"), common_sigOut_reg) @[multi.scala 46:36]
    common_sigOut_reg <= common_sigOut @[multi.scala 46:36]
    node _io_invalidExc_T = eq(io.a.isInf, UInt<1>("h0")) @[multi.scala 19:16]
    node _io_invalidExc_T_1 = and(io.a.isNaN, _io_invalidExc_T) @[multi.scala 19:13]
    node _io_invalidExc_T_2 = eq(io.a.isZero, UInt<1>("h0")) @[multi.scala 19:28]
    node _io_invalidExc_T_3 = and(_io_invalidExc_T_1, _io_invalidExc_T_2) @[multi.scala 19:25]
    node _io_invalidExc_T_4 = eq(io.a.exp, UInt<9>("h1ff")) @[multi.scala 19:47]
    node _io_invalidExc_T_5 = and(_io_invalidExc_T_3, _io_invalidExc_T_4) @[multi.scala 19:38]
    node _io_invalidExc_T_6 = bits(io.a.sig, 22, 22) @[multi.scala 19:83]
    node _io_invalidExc_T_7 = eq(_io_invalidExc_T_6, UInt<1>("h0")) @[multi.scala 19:98]
    node _io_invalidExc_T_8 = and(_io_invalidExc_T_5, _io_invalidExc_T_7) @[multi.scala 19:75]
    node _io_invalidExc_T_9 = bits(io.a.sig, 21, 0) @[multi.scala 19:114]
    node _io_invalidExc_T_10 = neq(_io_invalidExc_T_9, UInt<1>("h0")) @[multi.scala 19:132]
    node _io_invalidExc_T_11 = and(_io_invalidExc_T_8, _io_invalidExc_T_10) @[multi.scala 19:106]
    node _io_invalidExc_T_12 = eq(io.b.isInf, UInt<1>("h0")) @[multi.scala 19:16]
    node _io_invalidExc_T_13 = and(io.b.isNaN, _io_invalidExc_T_12) @[multi.scala 19:13]
    node _io_invalidExc_T_14 = eq(io.b.isZero, UInt<1>("h0")) @[multi.scala 19:28]
    node _io_invalidExc_T_15 = and(_io_invalidExc_T_13, _io_invalidExc_T_14) @[multi.scala 19:25]
    node _io_invalidExc_T_16 = eq(io.b.exp, UInt<9>("h1ff")) @[multi.scala 19:47]
    node _io_invalidExc_T_17 = and(_io_invalidExc_T_15, _io_invalidExc_T_16) @[multi.scala 19:38]
    node _io_invalidExc_T_18 = bits(io.b.sig, 22, 22) @[multi.scala 19:83]
    node _io_invalidExc_T_19 = eq(_io_invalidExc_T_18, UInt<1>("h0")) @[multi.scala 19:98]
    node _io_invalidExc_T_20 = and(_io_invalidExc_T_17, _io_invalidExc_T_19) @[multi.scala 19:75]
    node _io_invalidExc_T_21 = bits(io.b.sig, 21, 0) @[multi.scala 19:114]
    node _io_invalidExc_T_22 = neq(_io_invalidExc_T_21, UInt<1>("h0")) @[multi.scala 19:132]
    node _io_invalidExc_T_23 = and(_io_invalidExc_T_20, _io_invalidExc_T_22) @[multi.scala 19:106]
    node _io_invalidExc_T_24 = or(_io_invalidExc_T_11, _io_invalidExc_T_23) @[multi.scala 49:59]
    node _io_invalidExc_T_25 = or(_io_invalidExc_T_24, notSigNaN_invalidExc) @[multi.scala 49:99]
    io.invalidExc <= _io_invalidExc_T_25 @[multi.scala 49:19]
    io.rawOut.isInf <= notNaN_isInfOut @[multi.scala 50:21]
    io.rawOut.isZero <= notNaN_isZeroOut @[multi.scala 51:22]
    node _io_rawOut_isNaN_T = or(io.a.isNaN, io.b.isNaN) @[multi.scala 53:35]
    io.rawOut.isNaN <= _io_rawOut_isNaN_T @[multi.scala 53:21]
    when notNaN_isZeroOut : @[multi.scala 55:29]
      io.rawOut.exp <= UInt<1>("h0") @[multi.scala 56:23]
      io.rawOut.sig <= UInt<1>("h0") @[multi.scala 57:23]
    else :
      node _T = bits(common_sigOut, 47, 47) @[multi.scala 58:31]
      node _T_1 = eq(_T, UInt<1>("h1")) @[multi.scala 58:54]
      when _T_1 : @[multi.scala 58:63]
        node _io_rawOut_exp_T = add(common_expOut_reg, UInt<1>("h1")) @[multi.scala 59:44]
        node _io_rawOut_exp_T_1 = tail(_io_rawOut_exp_T, 1) @[multi.scala 59:44]
        io.rawOut.exp <= _io_rawOut_exp_T_1 @[multi.scala 59:23]
        node _io_rawOut_sig_T = shl(common_sigOut_reg, 1) @[multi.scala 60:44]
        io.rawOut.sig <= _io_rawOut_sig_T @[multi.scala 60:23]
      else :
        io.rawOut.exp <= common_expOut_reg @[multi.scala 62:23]
        node _io_rawOut_sig_T_1 = shl(common_sigOut_reg, 2) @[multi.scala 63:44]
        io.rawOut.sig <= _io_rawOut_sig_T_1 @[multi.scala 63:23]


  module MulRawFN :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip a : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, exp : UInt<9>, sig : UInt<23>}, flip b : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, exp : UInt<9>, sig : UInt<23>}, invalidExc : UInt<1>, rawOut : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, exp : UInt<9>, sig : UInt<23>}}

    inst mulFullRaw of MulFullRawFN @[multi.scala 77:28]
    mulFullRaw.clock <= clock
    mulFullRaw.reset <= reset
    mulFullRaw.io.a.sig <= io.a.sig @[multi.scala 79:21]
    mulFullRaw.io.a.exp <= io.a.exp @[multi.scala 79:21]
    mulFullRaw.io.a.isZero <= io.a.isZero @[multi.scala 79:21]
    mulFullRaw.io.a.isInf <= io.a.isInf @[multi.scala 79:21]
    mulFullRaw.io.a.isNaN <= io.a.isNaN @[multi.scala 79:21]
    mulFullRaw.io.b.sig <= io.b.sig @[multi.scala 80:21]
    mulFullRaw.io.b.exp <= io.b.exp @[multi.scala 80:21]
    mulFullRaw.io.b.isZero <= io.b.isZero @[multi.scala 80:21]
    mulFullRaw.io.b.isInf <= io.b.isInf @[multi.scala 80:21]
    mulFullRaw.io.b.isNaN <= io.b.isNaN @[multi.scala 80:21]
    io.invalidExc <= mulFullRaw.io.invalidExc @[multi.scala 82:19]
    io.rawOut <= mulFullRaw.io.rawOut @[multi.scala 83:15]
    node guardBit = bits(mulFullRaw.io.rawOut.sig, 24, 24) @[multi.scala 86:23]
    node roundBit = bits(mulFullRaw.io.rawOut.sig, 23, 23) @[multi.scala 87:23]
    node _stickyBit_T = bits(mulFullRaw.io.rawOut.sig, 22, 0) @[multi.scala 88:24]
    node stickyBit = orr(_stickyBit_T) @[multi.scala 88:42]
    node leastSigBitOfResult = bits(mulFullRaw.io.rawOut.sig, 25, 25) @[multi.scala 89:34]
    node _roundUp_T = or(roundBit, stickyBit) @[multi.scala 92:40]
    node _roundUp_T_1 = eq(roundBit, UInt<1>("h0")) @[multi.scala 92:55]
    node _roundUp_T_2 = eq(stickyBit, UInt<1>("h0")) @[multi.scala 92:67]
    node _roundUp_T_3 = and(_roundUp_T_1, _roundUp_T_2) @[multi.scala 92:65]
    node _roundUp_T_4 = and(_roundUp_T_3, leastSigBitOfResult) @[multi.scala 92:78]
    node _roundUp_T_5 = or(_roundUp_T, _roundUp_T_4) @[multi.scala 92:52]
    node roundUp = and(guardBit, _roundUp_T_5) @[multi.scala 92:28]
    node preRoundSig = bits(mulFullRaw.io.rawOut.sig, 47, 25) @[multi.scala 93:26]
    node _io_rawOut_sig_T = add(preRoundSig, UInt<1>("h1")) @[multi.scala 97:47]
    node _io_rawOut_sig_T_1 = tail(_io_rawOut_sig_T, 1) @[multi.scala 97:47]
    node _io_rawOut_sig_T_2 = mux(roundUp, _io_rawOut_sig_T_1, preRoundSig) @[multi.scala 97:25]
    io.rawOut.sig <= _io_rawOut_sig_T_2 @[multi.scala 97:19]

