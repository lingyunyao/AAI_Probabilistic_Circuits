circuit AddRawFN :
  module AddRawFN :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip a : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, exp : UInt<9>, sig : UInt<23>}, flip b : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, exp : UInt<9>, sig : UInt<23>}, invalidExc : UInt<1>, rawOut : { isNaN : UInt<1>, isInf : UInt<1>, isZero : UInt<1>, exp : UInt<9>, sig : UInt<23>}}

    node _notSigNaN_invalidExc_T = and(io.a.isInf, io.b.isZero) @[add.scala 37:44]
    node _notSigNaN_invalidExc_T_1 = and(io.a.isZero, io.b.isInf) @[add.scala 37:76]
    node notSigNaN_invalidExc = or(_notSigNaN_invalidExc_T, _notSigNaN_invalidExc_T_1) @[add.scala 37:60]
    node notNaN_isInfOut = or(io.a.isInf, io.b.isInf) @[add.scala 38:38]
    node notNaN_isZeroOut = or(io.a.isZero, io.b.isZero) @[add.scala 39:40]
    wire common_exp : UInt<9> @[add.scala 41:26]
    wire small_sig : UInt<23> @[add.scala 42:25]
    wire large_sig : UInt<23> @[add.scala 43:25]
    wire modNatAlignDist : UInt<10> @[add.scala 44:31]
    node _sDiffExps_T = cat(UInt<1>("h0"), io.a.exp) @[Cat.scala 33:92]
    node _sDiffExps_T_1 = cat(UInt<1>("h0"), io.b.exp) @[Cat.scala 33:92]
    node _sDiffExps_T_2 = sub(_sDiffExps_T, _sDiffExps_T_1) @[add.scala 46:45]
    node sDiffExps = tail(_sDiffExps_T_2, 1) @[add.scala 46:45]
    reg sDiffExps_reg : UInt, clock with :
      reset => (UInt<1>("h0"), sDiffExps_reg) @[add.scala 48:32]
    sDiffExps_reg <= sDiffExps @[add.scala 48:32]
    node _T = bits(sDiffExps_reg, 9, 9) @[add.scala 50:24]
    node _T_1 = eq(_T, UInt<1>("h1")) @[add.scala 50:35]
    when _T_1 : @[add.scala 50:49]
      node _modNatAlignDist_T = bits(sDiffExps_reg, 8, 0) @[add.scala 51:42]
      node _modNatAlignDist_T_1 = sub(UInt<1>("h0"), _modNatAlignDist_T) @[add.scala 51:28]
      node _modNatAlignDist_T_2 = tail(_modNatAlignDist_T_1, 1) @[add.scala 51:28]
      modNatAlignDist <= _modNatAlignDist_T_2 @[add.scala 51:25]
      common_exp <= io.b.exp @[add.scala 52:20]
      small_sig <= io.a.sig @[add.scala 53:19]
      large_sig <= io.b.sig @[add.scala 54:19]
    else :
      node _modNatAlignDist_T_3 = bits(sDiffExps_reg, 8, 0) @[add.scala 56:41]
      modNatAlignDist <= _modNatAlignDist_T_3 @[add.scala 56:25]
      common_exp <= io.a.exp @[add.scala 57:20]
      small_sig <= io.b.sig @[add.scala 58:19]
      large_sig <= io.a.sig @[add.scala 59:19]
    node pre_shifted_sig_hi = cat(UInt<2>("h1"), small_sig) @[Cat.scala 33:92]
    node _pre_shifted_sig_T = cat(pre_shifted_sig_hi, UInt<23>("h0")) @[Cat.scala 33:92]
    node pre_shifted_sig = dshr(_pre_shifted_sig_T, modNatAlignDist) @[add.scala 62:72]
    reg pre_shifted_sig_reg : UInt, clock with :
      reset => (UInt<1>("h0"), pre_shifted_sig_reg) @[add.scala 63:38]
    pre_shifted_sig_reg <= pre_shifted_sig @[add.scala 63:38]
    node _shifted_sig_T = gt(modNatAlignDist, UInt<5>("h18")) @[add.scala 65:43]
    node _shifted_sig_T_1 = mux(_shifted_sig_T, UInt<1>("h0"), pre_shifted_sig_reg) @[add.scala 65:26]
    node shifted_sig = bits(_shifted_sig_T_1, 47, 0) @[add.scala 65:88]
    reg shifted_sig_reg : UInt, clock with :
      reset => (UInt<1>("h0"), shifted_sig_reg) @[add.scala 66:34]
    shifted_sig_reg <= shifted_sig @[add.scala 66:34]
    node sig_sum_hi = cat(UInt<2>("h1"), large_sig) @[Cat.scala 33:92]
    node _sig_sum_T = cat(sig_sum_hi, UInt<23>("h0")) @[Cat.scala 33:92]
    node _sig_sum_T_1 = add(_sig_sum_T, shifted_sig_reg) @[add.scala 68:65]
    node _sig_sum_T_2 = tail(_sig_sum_T_1, 1) @[add.scala 68:65]
    node sig_sum = bits(_sig_sum_T_2, 47, 0) @[add.scala 68:83]
    reg sig_sum_reg : UInt, clock with :
      reset => (UInt<1>("h0"), sig_sum_reg) @[add.scala 69:30]
    sig_sum_reg <= sig_sum @[add.scala 69:30]
    wire fullrawout_exp : UInt<9> @[add.scala 71:30]
    wire fullrawout_sig : UInt<48> @[add.scala 72:30]
    node _T_2 = bits(sig_sum_reg, 47, 47) @[add.scala 74:22]
    node _T_3 = eq(_T_2, UInt<1>("h1")) @[add.scala 74:41]
    when _T_3 : @[add.scala 74:55]
      node _fullrawout_sig_T = shl(sig_sum, 1) @[add.scala 75:33]
      fullrawout_sig <= _fullrawout_sig_T @[add.scala 75:22]
      node _fullrawout_exp_T = add(common_exp, UInt<1>("h1")) @[add.scala 76:36]
      node _fullrawout_exp_T_1 = tail(_fullrawout_exp_T, 1) @[add.scala 76:36]
      fullrawout_exp <= _fullrawout_exp_T_1 @[add.scala 76:22]
    else :
      node _fullrawout_sig_T_1 = shl(sig_sum, 2) @[add.scala 79:33]
      fullrawout_sig <= _fullrawout_sig_T_1 @[add.scala 79:22]
      fullrawout_exp <= common_exp @[add.scala 80:22]
    reg fullrawout_exp_reg : UInt, clock with :
      reset => (UInt<1>("h0"), fullrawout_exp_reg) @[add.scala 84:37]
    fullrawout_exp_reg <= fullrawout_exp @[add.scala 84:37]
    reg fullrawout_sig_reg : UInt, clock with :
      reset => (UInt<1>("h0"), fullrawout_sig_reg) @[add.scala 85:37]
    fullrawout_sig_reg <= fullrawout_sig @[add.scala 85:37]
    node guardBit = bits(fullrawout_sig_reg, 24, 24) @[add.scala 88:23]
    node roundBit = bits(fullrawout_sig_reg, 23, 23) @[add.scala 89:23]
    node _stickyBit_T = bits(fullrawout_sig_reg, 22, 0) @[add.scala 90:24]
    node stickyBit = orr(_stickyBit_T) @[add.scala 90:42]
    node leastSigBitOfResult = bits(fullrawout_sig_reg, 25, 25) @[add.scala 91:34]
    node _roundUp_T = or(roundBit, stickyBit) @[add.scala 94:40]
    node _roundUp_T_1 = eq(roundBit, UInt<1>("h0")) @[add.scala 94:55]
    node _roundUp_T_2 = eq(stickyBit, UInt<1>("h0")) @[add.scala 94:67]
    node _roundUp_T_3 = and(_roundUp_T_1, _roundUp_T_2) @[add.scala 94:65]
    node _roundUp_T_4 = and(_roundUp_T_3, leastSigBitOfResult) @[add.scala 94:78]
    node _roundUp_T_5 = or(_roundUp_T, _roundUp_T_4) @[add.scala 94:52]
    node roundUp = and(guardBit, _roundUp_T_5) @[add.scala 94:28]
    node preRoundSig = bits(fullrawout_sig_reg, 47, 25) @[add.scala 95:26]
    node _rawOut_sig_reg_T = add(preRoundSig, UInt<1>("h1")) @[add.scala 97:59]
    node _rawOut_sig_reg_T_1 = tail(_rawOut_sig_reg_T, 1) @[add.scala 97:59]
    node _rawOut_sig_reg_T_2 = mux(roundUp, _rawOut_sig_reg_T_1, preRoundSig) @[add.scala 97:37]
    reg rawOut_sig_reg : UInt, clock with :
      reset => (UInt<1>("h0"), rawOut_sig_reg) @[add.scala 97:33]
    rawOut_sig_reg <= _rawOut_sig_reg_T_2 @[add.scala 97:33]
    io.rawOut.sig <= rawOut_sig_reg @[add.scala 98:19]
    io.rawOut.exp <= fullrawout_exp @[add.scala 100:19]
    node _io_rawOut_isNaN_T = or(io.a.isNaN, io.b.isNaN) @[add.scala 101:35]
    io.rawOut.isNaN <= _io_rawOut_isNaN_T @[add.scala 101:21]
    io.rawOut.isInf <= notNaN_isInfOut @[add.scala 102:21]
    io.rawOut.isZero <= notNaN_isZeroOut @[add.scala 103:22]
    node _io_invalidExc_T = eq(io.a.isInf, UInt<1>("h0")) @[add.scala 18:16]
    node _io_invalidExc_T_1 = and(io.a.isNaN, _io_invalidExc_T) @[add.scala 18:13]
    node _io_invalidExc_T_2 = eq(io.a.isZero, UInt<1>("h0")) @[add.scala 18:28]
    node _io_invalidExc_T_3 = and(_io_invalidExc_T_1, _io_invalidExc_T_2) @[add.scala 18:25]
    node _io_invalidExc_T_4 = bits(io.a.exp, 7, 0) @[add.scala 18:46]
    node _io_invalidExc_T_5 = eq(_io_invalidExc_T_4, UInt<8>("hff")) @[add.scala 18:64]
    node _io_invalidExc_T_6 = and(_io_invalidExc_T_3, _io_invalidExc_T_5) @[add.scala 18:38]
    node _io_invalidExc_T_7 = bits(io.a.sig, 22, 22) @[add.scala 18:100]
    node _io_invalidExc_T_8 = eq(_io_invalidExc_T_7, UInt<1>("h0")) @[add.scala 18:115]
    node _io_invalidExc_T_9 = and(_io_invalidExc_T_6, _io_invalidExc_T_8) @[add.scala 18:92]
    node _io_invalidExc_T_10 = bits(io.a.sig, 21, 0) @[add.scala 18:131]
    node _io_invalidExc_T_11 = neq(_io_invalidExc_T_10, UInt<1>("h0")) @[add.scala 18:149]
    node _io_invalidExc_T_12 = and(_io_invalidExc_T_9, _io_invalidExc_T_11) @[add.scala 18:123]
    node _io_invalidExc_T_13 = eq(io.b.isInf, UInt<1>("h0")) @[add.scala 18:16]
    node _io_invalidExc_T_14 = and(io.b.isNaN, _io_invalidExc_T_13) @[add.scala 18:13]
    node _io_invalidExc_T_15 = eq(io.b.isZero, UInt<1>("h0")) @[add.scala 18:28]
    node _io_invalidExc_T_16 = and(_io_invalidExc_T_14, _io_invalidExc_T_15) @[add.scala 18:25]
    node _io_invalidExc_T_17 = bits(io.b.exp, 7, 0) @[add.scala 18:46]
    node _io_invalidExc_T_18 = eq(_io_invalidExc_T_17, UInt<8>("hff")) @[add.scala 18:64]
    node _io_invalidExc_T_19 = and(_io_invalidExc_T_16, _io_invalidExc_T_18) @[add.scala 18:38]
    node _io_invalidExc_T_20 = bits(io.b.sig, 22, 22) @[add.scala 18:100]
    node _io_invalidExc_T_21 = eq(_io_invalidExc_T_20, UInt<1>("h0")) @[add.scala 18:115]
    node _io_invalidExc_T_22 = and(_io_invalidExc_T_19, _io_invalidExc_T_21) @[add.scala 18:92]
    node _io_invalidExc_T_23 = bits(io.b.sig, 21, 0) @[add.scala 18:131]
    node _io_invalidExc_T_24 = neq(_io_invalidExc_T_23, UInt<1>("h0")) @[add.scala 18:149]
    node _io_invalidExc_T_25 = and(_io_invalidExc_T_22, _io_invalidExc_T_24) @[add.scala 18:123]
    node _io_invalidExc_T_26 = or(_io_invalidExc_T_12, _io_invalidExc_T_25) @[add.scala 104:59]
    node _io_invalidExc_T_27 = or(_io_invalidExc_T_26, notSigNaN_invalidExc) @[add.scala 104:99]
    io.invalidExc <= _io_invalidExc_T_27 @[add.scala 104:19]

