import chisel3._
import chisel3.stage.{ChiselStage, ChiselGeneratorAnnotation}
//import consts._
import hardfloat._
import chisel3.util._

class RawFloat(expWidth: Int, sigWidth: Int) extends Bundle {
  val isNaN = Bool()
  val isInf = Bool()
  val isZero = Bool()
  val sExp = UInt((expWidth + 1).W) // Increase exponent width by 1
  val sig = UInt(sigWidth.W)
}

object Utils {
  def isSigNaNUnsignedRawFloat(x: RawFloat): Bool = {
    val expWidth = x.sExp.getWidth - 1
    val sigWidth = x.sig.getWidth
    x.isNaN && !x.isInf && !x.isZero && x.sExp(expWidth - 1, 0) === ((1 << expWidth) - 1).U && x.sig(sigWidth - 1) === 0.U && x.sig(sigWidth - 2, 0) =/= 0.U
  }
}

class MulFullRawFN(expWidth: Int, sigWidth: Int) extends chisel3.RawModule
{
    val io = IO(new Bundle {
        val a = Input(new RawFloat(expWidth, sigWidth))
        val b = Input(new RawFloat(expWidth, sigWidth))
        val invalidExc = Output(Bool())
        val rawOut = Output(new RawFloat(expWidth, (sigWidth+1)*2))
    })

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    val notSigNaN_invalidExc = (io.a.isInf && io.b.isZero) || (io.a.isZero && io.b.isInf)
    val notNaN_isInfOut = io.a.isInf || io.b.isInf
    val notNaN_isZeroOut = io.a.isZero || io.b.isZero
    //val notNaN_signOut = io.a.sign ^ io.b.sign
    val bias = (1 << (expWidth - 1)) - 1
    val common_sExpOut = io.a.sExp + io.b.sExp - bias.U
    //val common_sExpOut = io.a.sExp + io.b.sExp - (1<<expWidth).S
    val common_sigOut = (Cat(1.U(1.W),io.a.sig) * Cat(1.U(1.W),io.b.sig))((sigWidth+1)*2 - 1, 0)
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    //io.invalidExc := isSigNaNRawFloat(io.a) || isSigNaNRawFloat(io.b) || notSigNaN_invalidExc
    io.invalidExc := Utils.isSigNaNUnsignedRawFloat(io.a) || Utils.isSigNaNUnsignedRawFloat(io.b) || notSigNaN_invalidExc
    io.rawOut.isInf := notNaN_isInfOut
    io.rawOut.isZero := notNaN_isZeroOut
    //io.rawOut.sExp := common_sExpOut
    io.rawOut.isNaN := io.a.isNaN || io.b.isNaN
    //io.rawOut.sign := notNaN_signOut
    when (notNaN_isZeroOut) {
        //io.rawOut.sExp := 0.S(expWidth.W)
        //io.rawOut.sig := 0.U(((sigWidth+1)*2).W)
        io.rawOut.sExp := 0.U
        io.rawOut.sig := 0.U
    } .elsewhen (common_sigOut((sigWidth+1)*2 - 1)=== 1.U) {
        io.rawOut.sExp := common_sExpOut + 1.U
        io.rawOut.sig := common_sigOut << 1
    }.otherwise {
        io.rawOut.sExp := common_sExpOut
        io.rawOut.sig := common_sigOut
    }
}

class MulRawFN(expWidth: Int, sigWidth: Int) extends chisel3.RawModule
{
    val io = IO(new Bundle {
        val a = Input(new RawFloat(expWidth, sigWidth))
        val b = Input(new RawFloat(expWidth, sigWidth))
        val invalidExc = Output(Bool())
        val rawOut = Output(new RawFloat(expWidth, sigWidth))
    })

    val mulFullRaw = Module(new MulFullRawFN(expWidth, sigWidth))

    mulFullRaw.io.a := io.a
    mulFullRaw.io.b := io.b

    io.invalidExc := mulFullRaw.io.invalidExc
    io.rawOut := mulFullRaw.io.rawOut
    /*io.rawOut.sig := {
      val sig = mulFullRaw.io.rawOut.sig
      //Cat(sig >> (sigWidth - 2), sig(sigWidth - 3, 0).orR)
      Cat(sig >> (sigWidth + 3), sig(sigWidth - 3, 0).orR)
    }*/
    val sig = mulFullRaw.io.rawOut.sig
    val roundBit = sig(sigWidth)
    val stickyBit = sig(sigWidth - 1, 0).orR
    val roundUp = roundBit & (sig(sigWidth + 1) | stickyBit)
    io.rawOut.sig := Mux(roundUp, sig((sigWidth*2) + 1, sigWidth + 2) + 1.U, sig((sigWidth*2) + 1, sigWidth + 2))

}
